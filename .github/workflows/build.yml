name: CI â€” Build Rust, Python & Java bindings

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-matrix:
    name: Build (${{ matrix.os }} / ${{ matrix.arch }})
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        arch: [x64, arm64]
      fail-fast: false
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install uv and set up Python
        uses: astral-sh/setup-uv@v6
        with:
          enable-cache: true

      - name: Set up JDK 25 (for building Java bindings)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '25'

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Determine Rust target triple
        id: target
        run: |
          echo "Matrix: ${{ matrix.os }} / ${{ matrix.arch }}"
          case "${{ matrix.os }}:${{ matrix.arch }}" in
            "ubuntu-latest:x64") echo "TARGET_TRIPLE=x86_64-unknown-linux-gnu" >> $GITHUB_ENV ;;
            "ubuntu-latest:arm64") echo "TARGET_TRIPLE=aarch64-unknown-linux-gnu" >> $GITHUB_ENV ;;
            "macos-latest:x64") echo "TARGET_TRIPLE=x86_64-apple-darwin" >> $GITHUB_ENV ;;
            "macos-latest:arm64") echo "TARGET_TRIPLE=aarch64-apple-darwin" >> $GITHUB_ENV ;;
            "windows-latest:x64") echo "TARGET_TRIPLE=x86_64-pc-windows-msvc" >> $GITHUB_ENV ;;
            "windows-latest:arm64") echo "TARGET_TRIPLE=aarch64-pc-windows-msvc" >> $GITHUB_ENV ;;
            *) echo "TARGET_TRIPLE=x86_64-unknown-linux-gnu" >> $GITHUB_ENV ;;
          esac
          echo "TARGET_TRIPLE=$TARGET_TRIPLE"

      - name: Add rust target
        run: |
          rustup target add "$TARGET_TRIPLE"

      - name: Cache Cargo registry and index
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-registry-${{ matrix.arch }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-registry-${{ matrix.arch }}-

      - name: Cache Cargo target directory
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-target-${{ matrix.arch }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-target-${{ matrix.arch }}-

      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ matrix.arch }}-${{ hashFiles('bindings/java/**') }}
          restore-keys: |
            ${{ runner.os }}-gradle-${{ matrix.arch }}-

      - name: Try restore previous build artifact (target directory)
        if: always()
        shell: bash
        run: |
          set -eux
          ARTIFACT_NAME="build-${{ matrix.os }}-${{ matrix.arch }}"
          echo "Searching for artifact named $ARTIFACT_NAME in repo ${GITHUB_REPOSITORY}"
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts"
          TOKEN="${{ secrets.GITHUB_TOKEN }}"
          # fetch artifacts list (first page)
          resp=$(curl -s -H "Authorization: token $TOKEN" "$API_URL")
          # try to extract matching artifact id using python for robust JSON parsing
          artifact_id=$(printf "%s" "$resp" | python3 -c "import sys,json; a=json.load(sys.stdin); name='$ARTIFACT_NAME'; ids=[x.get('id') for x in a.get('artifacts',[]) if x.get('name')==name]; print(ids[0] if ids else '')")
          if [ -z "$artifact_id" ]; then
            echo "No artifact found for $ARTIFACT_NAME"
          else
            echo "Found artifact id $artifact_id, downloading..."
            curl -s -H "Authorization: token $TOKEN" -L "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts/${artifact_id}/zip" -o /tmp/artifact.zip
            mkdir -p restored_artifact
            unzip -q /tmp/artifact.zip -d restored_artifact
            # move possible target dir into current workspace
            if [ -d restored_artifact/target ]; then
              echo "Restoring target/ from artifact"
              rm -rf target || true
              mv restored_artifact/target ./
            else
              echo "No target/ in artifact"
            fi
          fi

      - name: Cargo build (Rust library workspace)
        run: |
          cargo build --workspace --release --target "$TARGET_TRIPLE"

      - name: Build Python bindings (maturin)
        run: |
          uv pip install maturin setuptools wheel --system
          cd bindings/python
          # Attempt a target-aware maturin build. Some cross-compiles may require extra toolchain support.
          uv run --system maturin build --release --strip --manylinux off --target "$TARGET_TRIPLE" || true
        shell: bash

      - name: Build Java bindings (Gradle)
        working-directory: bindings/java
        env:
          RUST_TARGET_DIR: ${{ github.workspace }}/target
          RUST_BUILD_TARGET: ${{ env.TARGET_TRIPLE }}
          SKIP_RUST_BUILD: "true"
        run: |
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            call gradlew.bat -q build -PSKIP_RUST_BUILD=true -PRUST_TARGET_DIR=%RUST_TARGET_DIR% -PRUST_BUILD_TARGET=%RUST_BUILD_TARGET%
          else
            ./gradlew -q build -PSKIP_RUST_BUILD=true -PRUST_TARGET_DIR=$RUST_TARGET_DIR -PRUST_BUILD_TARGET=$RUST_BUILD_TARGET
          fi
        shell: bash

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.os }}-${{ matrix.arch }}
          path: |
            target/${{ env.TARGET_TRIPLE }}/release/**/*
            bindings/python/target/wheels/**/*
            bindings/java/build/libs/**/*

    # Notes:
    # - This workflow uses a matrix over OS and architecture and maps them to Rust target triples.
    # - Many cross-compilation scenarios (macOS/Windows arm64) may require additional toolchains or
    #   self-hosted runners. Where cross-compilation is non-trivial, the workflow attempts a best-effort build
    #   but may fail (e.g. maturin or cargo linking errors). See the repository README for guidance on
    #   running builds locally or in a runner with the proper toolchain installed.
    #
    # uv caching:
    # - The astral-sh/setup-uv@v6 action with enable-cache: true automatically persists the uv cache
    #   across workflow runs using GitHub's cache service. This speeds up dependency installation.
    # - Python bindings are built with uv pip (using --system flag) to install maturin and build the
    #   PyO3 extension wheels.
    #
    # Gradle optimization:
    # - The Gradle build receives the RUST_TARGET_DIR and RUST_BUILD_TARGET as properties to reuse the
    #   prebuilt Rust artifacts (target/${{ env.TARGET_TRIPLE }}/release/*) from the prior cargo build step.
    # - The SKIP_RUST_BUILD property can be used to prevent Gradle from running cargo build again,
    #   reducing build time. Update bindings/java/build.gradle.kts to check this property.
    #
    # Artifact-based caching details:
    # - The workflow attempts to restore a previous workflow run's artifact named
    #   `build-<os>-<arch>` (e.g. `build-ubuntu-latest-x64`) and, if it contains a `target/` directory,
    #   will copy it into the workspace before running `cargo build`. This can speed up builds by reusing
    #   previously compiled objects. The step uses the GitHub Actions REST API and the $GITHUB_TOKEN to
    #   find and download the most recent matching artifact from the repository's artifacts list (first page).
    # - The artifact restore is best-effort: it only inspects the first page of artifacts and will skip if
    #   none is found. If you need a more robust cross-run cache, consider publishing build artifacts to a
    #   release or using a dedicated object store.
    # - The workflow still uploads the `build-<os>-<arch>` artifact at the end of each matrix job so subsequent
    #   runs may restore it.
    #
    # Caching keys:
    # - We use `actions/cache` for the Cargo registry/git, the `target/` directory, and the Gradle cache.
    #   Keys include the runner OS and the matrix architecture plus a hash of relevant files to improve cache
    #   hit rate across changes.
